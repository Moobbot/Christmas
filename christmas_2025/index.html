<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas 2025 - Neon Heart 3D</title>
    <style>
        body {
            margin: 0;
            background-color: #050510;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #ddd;
            font-family: monospace;
        }

        canvas {
            background: #000;
            display: block;
            /* Removes bottom scrollbar ghost */
        }

        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="debug">FPS: 60<br>Mode: 3D</div>
    <script>
        // --- CONFIGURATION ---
        // Width/Height will be overwritten by resize()
        const CONFIG = {
            WIDTH: 1080,
            HEIGHT: 1920,
            DURATION: 6.0,    // Time to draw heart in seconds
            PARTICLES: 20000,
            SEED: 42,
            FPS_UPDATE_INTERVAL: 500,
            FOCAL_LENGTH: 800 // For 3D Projection
        };

        // --- SEEDED RANDOM ---
        let seedState = CONFIG.SEED;
        function random() {
            // Simple LCG
            seedState = (seedState * 1664525 + 1013904223) % 4294967296;
            return seedState / 4294967296;
        }

        // --- STATE ---
        let canvas, ctx;
        let bufferCanvas, bufferCtx; // For trail & bloom
        let particles = [];
        let trailPoints = []; // Stores {x, y, z, color}
        let startTime = 0;
        let lastTime = 0;
        let isDrawing = false;
        let lastFpsTime = 0;
        let framesSinceLastFps = 0;

        // Camera rotation
        let camAngleY = 0;

        // --- INIT ---
        function init() {
            canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            ctx = canvas.getContext('2d');

            // Buffer for the glowing trail
            bufferCanvas = document.createElement('canvas');
            bufferCtx = bufferCanvas.getContext('2d');

            // Responsive sizing
            window.addEventListener('resize', () => {
                resize();
                restart(); // Restart on resize to respawn particles within new bounds
            });
            resize(); // Initial resize

            // Controls
            window.addEventListener('keydown', (e) => {
                if (e.key === 'r' || e.key === 'R') restart();
            });

            // Note: restart() is called inside resize() so we don't need it here
            requestAnimationFrame(loop);
        }

        function resize() {
            // Full screen dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            bufferCanvas.width = window.innerWidth;
            bufferCanvas.height = window.innerHeight;

            // Update Config
            CONFIG.WIDTH = window.innerWidth;
            CONFIG.HEIGHT = window.innerHeight;
        }

        function restart() {
            seedState = CONFIG.SEED; // Reset seed
            particles = [];
            trailPoints = [];
            camAngleY = 0;

            // init particles in 3D
            for (let i = 0; i < CONFIG.PARTICLES; i++) {
                // Random position in a sphere roughly size of screen
                const r = Math.min(CONFIG.WIDTH, CONFIG.HEIGHT) * 0.8 * Math.cbrt(random());
                const theta = random() * Math.PI * 2;
                const phi = Math.acos(2 * random() - 1);

                particles.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi),
                    vx: (random() - 0.5) * 2,
                    vy: (random() - 0.5) * 2,
                    vz: (random() - 0.5) * 2,
                    size: random() * 2 + 0.5,
                    alpha: random(),
                    phase: random() * Math.PI * 2
                });
            }

            // Clear buffer
            bufferCtx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            startTime = performance.now();
            isDrawing = true;
        }

        // --- 3D MATH ---
        function rotateY(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos - z * sin,
                y: y,
                z: x * sin + z * cos
            };
        }

        function project(x, y, z) {
            // Camera is at (0, 0, -FOCAL_LENGTH*2)? No, assume camera is at origin looking at World.
            // Actually usually we move World away from Camera.
            // Let's assume World center is (0,0,0) and Camera is at (0, 0, -1000).
            // So we shift Z by +1000 before projection.

            const zOffset = 1000;
            const contextZ = z + zOffset; // Distance from camera

            if (contextZ <= 0) return null; // Behind camera

            const scale = CONFIG.FOCAL_LENGTH / contextZ;

            return {
                x: x * scale + CONFIG.WIDTH / 2, // Center on screen
                y: y * scale + CONFIG.HEIGHT / 2,
                scale: scale,
                z: z // Keep original Z for sorting if needed
            };
        }

        // --- HEART MATH ---
        function getHeartPoint(t) {
            const rad = t * Math.PI * 2;

            // Scale based on screen size
            const minDim = Math.min(CONFIG.WIDTH, CONFIG.HEIGHT);
            const scale = minDim / 40;

            const a = 16;
            const b = 1;

            // 2D Heart Formula
            const xRaw = a * Math.pow(Math.sin(rad), 3);
            const yRaw = (13 * Math.cos(rad) - 5 * Math.cos(2 * rad) - 2 * Math.cos(3 * rad) - Math.cos(4 * rad)) / b;

            // Convert to 3D world coords
            // We'll give it a slight curve in Z too to make it interesting? 
            // Or just flat heart rotating? Let's do flat heart first.
            // x, y centered at 0,0

            const x = xRaw * scale;
            const y = -yRaw * scale; // Flip Y
            const z = 0;

            return { x, y, z };
        }

        // --- LOOP ---
        function loop(now) {
            requestAnimationFrame(loop);

            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            // FPS Calc
            if (now - lastFpsTime > CONFIG.FPS_UPDATE_INTERVAL) {
                const fps = Math.round(framesSinceLastFps * 1000 / (now - lastFpsTime));
                document.getElementById('debug').innerHTML = `FPS: ${fps}<br>Mode: 3D`;
                lastFpsTime = now;
                framesSinceLastFps = 0;
            }
            framesSinceLastFps++;

            // Auto Rotate Camera
            camAngleY += dt * 0.3; // Slow rotation

            // Animation Logic
            const elapsed = (now - startTime) / 1000;
            let progress = 0;
            if (elapsed < CONFIG.DURATION) {
                progress = elapsed / CONFIG.DURATION;
                isDrawing = true;
            } else {
                progress = 1;
                isDrawing = false;
            }

            // Rainbow Hue: 0 (Red) -> 280 (Purple)
            const currentHue = progress * 280;
            const currentColorHslaPrefix = `hsla(${currentHue}, 100%, 70%,`;
            const currentColorHsl = `hsl(${currentHue}, 100%, 70%)`;

            // Current Drawing Head in WORLD space
            const headWorld = getHeartPoint(progress);

            // Add head to trail
            if (isDrawing) {
                if (trailPoints.length === 0) {
                    trailPoints.push({ ...headWorld, color: currentColorHsl });
                } else {
                    const last = trailPoints[trailPoints.length - 1];
                    const dist = Math.hypot(headWorld.x - last.x, headWorld.y - last.y, headWorld.z - last.z);
                    if (dist > 5) {
                        trailPoints.push({ ...headWorld, color: currentColorHsl });
                    }
                }
            }

            // --- UPDATE & RENDER ---

            // 1. Clear Main
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // 2. Draw 3D Particles
            ctx.globalCompositeOperation = 'lighter';

            // To make 3D logic correct we really should project everything first
            // But updating logic needs World coords.

            for (let i = 0; i < CONFIG.PARTICLES; i++) {
                const p = particles[i];
                p.alpha = 0.3 + 0.5 * Math.sin(now * 0.005 + p.phase);

                // Attraction to head (WORLD SPACE)
                if (isDrawing) {
                    const dx = headWorld.x - p.x;
                    const dy = headWorld.y - p.y;
                    const dz = headWorld.z - p.z;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    const force = 20000 / (distSq + 2000);

                    // 3D vector logic can be tricky without vector class
                    // Normalized dir
                    const dist = Math.sqrt(distSq);
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const nz = dz / dist;

                    // Pull
                    p.vx += nx * force * 5.0;
                    p.vy += ny * force * 5.0;
                    p.vz += nz * force * 5.0;

                    // Swirl (Use cross product with Up vector? Simple swirl around Y?)
                    // Simple Tangent swirl?
                    // Let's just do random noise or simple swirl around Y axis
                    p.vx += -p.z * 0.001 * force;
                    p.vz += p.x * 0.001 * force;

                    // "Consumed" / Hit Condition
                    if (distSq < 200) {
                        // Instead of painting to buffer (which is 2D), we must now keep 3D points?
                        // Actually, we can't easily use the 2D buffer trail trick in 3D because the trail moves/rotates.
                        // We must RENDER the trail every frame in 3D.
                        // AND we can render "stardust" points that persist.
                        // For performance, let's just Respawn and NOT paint to buffer.
                        // OR we add static "dust" points to a list to be rendered.

                        // Let's maintain a "stardust" array? 20k particles is enough, let's just respawn.
                        // But user liked the "dense" line.
                        // We will render the Trail Points as dense dots. 

                        const respawnAngle = random() * Math.PI * 2;
                        const respawnDist = Math.max(CONFIG.WIDTH, CONFIG.HEIGHT) * 0.8;
                        // Respawn
                        p.x = headWorld.x + Math.cos(respawnAngle) * respawnDist;
                        p.y = headWorld.y + Math.sin(respawnAngle) * respawnDist;
                        p.z = (random() - 0.5) * 1000;
                        p.vx = (random() - 0.5);
                        p.vy = (random() - 0.5);
                        p.vz = (random() - 0.5);
                    }
                }

                // Physics
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;

                p.vx *= 0.92;
                p.vy *= 0.92;
                p.vz *= 0.92;

                if (!isDrawing) {
                    p.x += Math.sin(now * 0.001 + p.phase) * 0.2;
                    p.y += Math.cos(now * 0.001 + p.phase) * 0.2;
                    p.z += Math.sin(now * 0.002 + p.phase) * 0.2;
                }

                // 3D PROJECTION & DRAW
                // Rotate
                const rotated = rotateY(p.x, p.y, p.z, camAngleY);
                // Project
                const proj = project(rotated.x, rotated.y, rotated.z);

                if (proj) {
                    // Draw
                    const size = p.size * proj.scale;
                    ctx.fillStyle = currentColorHslaPrefix + p.alpha + ')';
                    ctx.fillRect(proj.x, proj.y, size, size);
                }
            }

            // 3. Draw Trail (3D Line + Dense Dots)
            // Since we can't use 2D buffer for rotating 3D object, we must draw it every frame.
            // This is more expensive but valid for modern PCs.

            if (trailPoints.length > 1) {
                // Draw Solid Line
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // We need to batch segments by color or draw individually
                // Individual segments for gradient

                for (let i = 0; i < trailPoints.length - 1; i++) {
                    const p1 = trailPoints[i];
                    const p2 = trailPoints[i + 1];

                    const r1 = rotateY(p1.x, p1.y, p1.z, camAngleY);
                    const r2 = rotateY(p2.x, p2.y, p2.z, camAngleY);

                    const proj1 = project(r1.x, r1.y, r1.z);
                    const proj2 = project(r2.x, r2.y, r2.z);

                    if (proj1 && proj2) {
                        ctx.strokeStyle = p1.color;
                        ctx.lineWidth = 4 * proj1.scale; // Scale thickness
                        ctx.beginPath();
                        ctx.moveTo(proj1.x, proj1.y);
                        ctx.lineTo(proj2.x, proj2.y);
                        ctx.stroke();

                        // Fake "Glow/Bloom" by drawing again wider and lower alpha?
                        // Or rely on global `ctx.filter`?
                        // `ctx.filter` affects everything. Let's try to not use it for per-segment to allow high FPS.
                        // Or just draw the "Dense Stardust" along the line?

                        // Simulate "Denser" stardust on the line
                        // Draw random dots around this segment
                        /*
                        ctx.fillStyle = p1.color;
                        const dustCount = 2; 
                        for(let j=0; j<dustCount; j++) {
                            const t = random();
                            const dx = (proj2.x - proj1.x) * t + proj1.x + (random()-0.5)*10*proj1.scale;
                            const dy = (proj2.y - proj1.y) * t + proj1.y + (random()-0.5)*10*proj1.scale;
                            ctx.fillRect(dx, dy, 2*proj1.scale, 2*proj1.scale);
                        }
                        */
                    }
                }
            }

            // 4. Draw Leading Head Glow
            if (isDrawing) {
                const rHead = rotateY(headWorld.x, headWorld.y, headWorld.z, camAngleY);
                const pHead = project(rHead.x, rHead.y, rHead.z);

                if (pHead) {
                    // Big radial glow
                    const radius = 60 * pHead.scale;
                    const grad = ctx.createRadialGradient(pHead.x, pHead.y, 10 * pHead.scale, pHead.x, pHead.y, radius);
                    grad.addColorStop(0, currentColorHsl);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');

                    ctx.fillStyle = grad;
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillRect(pHead.x - radius, pHead.y - radius, radius * 2, radius * 2);

                    // Bright tip
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(pHead.x, pHead.y, 4 * pHead.scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Start
        init();

    </script>
</body>
</html>