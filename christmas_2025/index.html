<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas 2025 - 6 Intersecting Hearts</title>
    <style>
        @font-face {
            font-family: 'Satisfy';
            src: url('../fonts/Satisfy/Satisfy-Regular.ttf') format('truetype');
        }

        @font-face {
            font-family: 'Quicksand';
            src: url('../fonts/Quicksand/Quicksand-VariableFont_wght.ttf') format('truetype');
        }

        body {
            margin: 0;
            background-color: #050510;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #ddd;
            font-family: monospace;
        }

        canvas {
            background: #000;
            display: block;
        }

        #debug {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: monospace;
            z-index: 10;
        }

        /* Image Container (Centered, floating) */
        #image-container {
            position: absolute;
            top: 0;
            left: 0;
            /* transform: translate(-50%, -50%); - moved to img */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: none;
            /* Let mouse pass through to canvas for coords */
        }

        #displayed-image {
            max-width: 400px;
            max-height: 400px;
            border: 5px solid #fff;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.8);
            border-radius: 15px;

            /* Hidden state */
            opacity: 0;
            transform: translate(-50%, -50%) scale(0);
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            /* Bouncy pop */
        }

        /* Visible state class */
        #displayed-image.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* --- POPUP MODAL CSS --- */
        #popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .popup-content {
            background: rgba(20, 20, 35, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 1px solid #ff0a54;
            color: #eee;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 50px rgba(255, 10, 84, 0.3);
            font-family: 'Quicksand', sans-serif;
            position: relative;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .popup-content h2 {
            color: #ff0a54;
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Satisfy', cursive;
            font-size: 2.2em;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .popup-content ul {
            list-style: none;
            padding: 0;
        }

        .popup-content li {
            margin-bottom: 12px;
            font-size: 1.1em;
            line-height: 1.5;
            padding-left: 25px;
            position: relative;
        }

        /* Bullet points as emojis or styled */
        .popup-content li::before {
            content: 'üéÅ';
            position: absolute;
            left: 0;
            top: 2px;
            font-size: 0.9em;
        }

        button#btn-close {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #ff0a54, #ff5c8a);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
            font-weight: bold;
        }

        button#btn-close:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 10, 84, 0.4);
        }
    </style>
</head>
<body>
    <div id="debug">FPS: 60<br>Mode: 6 Intersecting Planes</div>

    <!-- Image Container -->
    <div id="image-container">
        <img id="displayed-image" src="" alt="Christmas Memory">
    </div>

    <!-- POPUP OVERLAY (Instruction Modal) -->
    <div id="popup-overlay">
        <div class="popup-content">
            <h2>üéÑ H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng üéÑ</h2>
            <ul>
                <li><strong>Chu·ªôt tr√°i (Gi·ªØ & K√©o):</strong> Xoay l·∫≠t camera (360 ƒë·ªô).</li>
                <li><strong>Chu·ªôt ph·∫£i (Gi·ªØ & K√©o):</strong> Di chuy·ªÉn khung h√¨nh (Pan).</li>
                <li><strong>LƒÉn chu·ªôt:</strong> Ph√≥ng to / Thu nh·ªè.</li>
                <li><strong>Click v√†o Tr√°i Tim:</strong> Xem ·∫£nh k·ª∑ ni·ªám.</li>
            </ul>
            <p style="text-align: center; margin-top: 20px;">Ch√∫c b√© m·ªôt m√πa Gi√°ng Sinh an l√†nh! ‚ù§Ô∏è</p>
            <button id="btn-close">ƒê√£ hi·ªÉu</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            WIDTH: 1080,
            HEIGHT: 1920,
            PARTICLES: 20000, // S·ªë l∆∞·ª£ng h·∫°t
            HEART_COUNT: 8,   // 8 tr√°i tim
            HEART_SIZE: 15,   // K√≠ch th∆∞·ªõc
            SNOW_COUNT: 800,  // S·ªë l∆∞·ª£ng tuy·∫øt
            SNOW_FLOOR_COUNT: 1000,
            SHAPE_PARTICLES: 4000,
            FPS_UPDATE_INTERVAL: 500,
            FOCAL_LENGTH: 800
        };

        const IMAGES = [
            '../images/img_1.jpg',
            '../images/img_2.jpg',
            '../images/img_3.jpg'
        ];

        // --- STATE ---
        let canvas, ctx;
        let particles = [];
        let snowflakes = []; // RESTORED
        // let snowFloor = []; // REMOVED
        let galaxyParticles = []; // NEW: Galaxy Floor
        const GALAXY_COUNT = 2500;
        const GALAXY_COLORS = ['#0f0c29', '#302b63', '#24243e', '#00d2ff', '#3a7bd5', '#ffffff'];

        let accumulatedSnow = []; // Keep for falling snow sticking? Or remove? User said "replace snow floor".
        // I will keep accumulatedSnow as it adds interaction, but maybe disable "Snow Floor" static.
        const MAX_ACCUMULATED = 10000;
        let shapeParticles = [];
        let startTime = 0;
        let lastTime = 0;

        let snowImage;

        // ...

        function initGalaxyFloor() {
            galaxyParticles = [];
            for (let i = 0; i < GALAXY_COUNT; i++) {
                resetGalaxyParticle({}, true);
            }
        }

        function resetGalaxyParticle(p, initial = false) {
            // Galaxy on XZ plane at y = ~500 (Floor)

            // XZ plane radius
            const range = 2000; // Wider than screen usually
            const angle = Math.random() * Math.PI * 2;
            // Initial distribution spread out, reset distribution at edge?
            // Reference: radius = initial ? max : random*200 + ...
            const radius = initial
                ? Math.random() * range
                : Math.random() * 200 + range * 0.8;

            p.x = Math.cos(angle) * radius;
            p.z = Math.sin(angle) * radius;
            p.y = 500; // Floor Level

            p.vx = 0;
            p.vz = 0; // Velocity in XZ
            p.size = Math.random() * 2 + 0.5;
            p.color = GALAXY_COLORS[Math.floor(Math.random() * GALAXY_COLORS.length)];
            p.life = Math.random() * 300 + 100;
            p.friction = 0.96;

            // Push if new
            if (galaxyParticles.indexOf(p) === -1) galaxyParticles.push(p);
        }

        function updateAndDrawGalaxyFloor(now) {
            ctx.lineWidth = 1.5;

            // Xoay nh·∫π m√†u s·∫Øc theo th·ªùi gian? Reference static palette.

            for (let i = 0; i < galaxyParticles.length; i++) {
                let p = galaxyParticles[i];

                // PHYSICS (Converted from 2D Ref to 3D XZ)
                const dx = p.x; // Center is 0,0,0
                const dz = p.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                const angleToCenter = Math.atan2(dz, dx);

                // Suction Logic
                const suctionForce = 2.5;
                const noise = Math.sin(dist * 0.02 - now * 0.002) * 0.5;
                const angle = angleToCenter + Math.PI + 1.4 + noise;
                const gravitySpeed = 2 + (200 / (dist + 10));

                p.vx += Math.cos(angle) * 0.2;
                p.vz += Math.sin(angle) * 0.2;
                p.vx *= p.friction;
                p.vz *= p.friction;

                p.x += p.vx * gravitySpeed;
                p.z += p.vz * gravitySpeed;
                p.life--;

                // Reset Logic
                if (p.life <= 0 || dist < 10 || Math.abs(p.x) > 3000 || Math.abs(p.z) > 3000) {
                    resetGalaxyParticle(p);
                    continue;
                }

                // DRAW
                // Current Pos
                const r1 = applyCamera(p.x, p.y, p.z);
                const proj1 = project(r1.x, r1.y, r1.z);

                // Tail Pos (simulate motion blur)
                const tailX = p.x - p.vx * 4;
                const tailZ = p.z - p.vz * 4;
                const r2 = applyCamera(tailX, p.y, tailZ);
                const proj2 = project(r2.x, r2.y, r2.z);

                if (proj1 && proj2) {
                    ctx.beginPath();
                    ctx.strokeStyle = p.color; // Use sprite color? No, ref uses stroke.
                    ctx.lineWidth = p.size * proj1.scale;
                    // ctx.globalAlpha = 0.8; // Blend handled by drawBackground trail?

                    ctx.moveTo(proj1.x, proj1.y);
                    ctx.lineTo(proj2.x, proj2.y);
                    ctx.stroke();
                }
            }
        }

        // REMOVE OLD SNOW FLOOR FUNCS
        /*
        function initSnowFloor() { ... }
        function drawSnowFloor() { ... }
        */

        // Camera State
        let camAngleY = 0;
        let camAngleX = 0;
        let camZ = 2500; // Distance (Zoom)
        let camPanX = 0;
        let camPanY = 0;

        // Interaction State
        let isDragging = false;
        let isPanning = false; // New Panning State
        let lastMouseX = 0;
        let lastMouseY = 0;
        let dragStartX = 0;
        let dragStartY = 0;
        let isHovering = false;

        // M√†u cho 8 tr√°i tim
        const PALETTE = [
            'hsla(0, 100%, 60%, ',   // ƒê·ªè
            'hsla(30, 100%, 60%, ',  // Cam
            'hsla(60, 100%, 60%, ',  // V√†ng
            'hsla(120, 100%, 60%, ', // Xanh l√°
            'hsla(160, 100%, 60%, ', // Cyan
            'hsla(200, 100%, 60%, ', // Xanh d∆∞∆°ng
            'hsla(300, 100%, 60%, ', // T√≠m
            'hsla(330, 100%, 60%, '  // H·ªìng
        ];

        // --- INIT ---
        function init() {
            canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            ctx = canvas.getContext('2d');

            window.addEventListener('resize', resize);
            resize();

            // Prevent Context Menu on Right Click
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // MOUSE EVENTS
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isPanning = true;
                } else {
                    // Check Base Click (Popup Trigger)
                    const baseR = applyCamera(0, 500, 0); // Center of "Mirror Platform"
                    const baseProj = project(baseR.x, baseR.y, baseR.z);
                    if (baseProj) {
                        const dist = Math.hypot(e.clientX - baseProj.x, e.clientY - baseProj.y);
                        // Hitbox size (scaled or fixed? fixed is easier to hit)
                        if (dist < 150 * baseProj.scale) {
                            // OPEN POPUP
                            const overlay = document.getElementById('popup-overlay');
                            overlay.style.display = 'flex';
                            return; // Don't drag if clicked on base
                        }
                    }

                    isDragging = true;
                }
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            });

            // --- POPUP MODAL LOGIC ---
            const overlay = document.getElementById('popup-overlay');
            const btnClose = document.getElementById('btn-close');

            // Close Button
            if (btnClose) {
                btnClose.addEventListener('click', () => {
                    overlay.style.display = 'none';
                });
            }

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.style.display = 'none';
                }
            });

            window.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                // 0. Handle Panning (Right Click)
                if (isPanning) {
                    camPanX += deltaX;
                    camPanY += deltaY;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    return;
                }

                // 1. Handle Dragging (Left Click - Rotate)
                if (isDragging) {
                    camAngleY += deltaX * 0.005;
                    camAngleX += deltaY * 0.005;
                    camAngleX = Math.max(-0.5, Math.min(0.5, camAngleX));
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    return;
                }

                // 2. Handle Hover (Image Zoom)
                // Calculate Screen Position of the Heart Center (0,0,0) in 3D
                const r = applyCamera(0, 0, 0);
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    const dist = Math.hypot(e.clientX - proj.x, e.clientY - proj.y);
                    const img = document.getElementById('displayed-image');

                    if (dist < 100 * proj.scale) { // Scale hit area with zoom? Or keep fixed? Fixed 100 is easier to hit.
                        // Let's scale it slightly so it doesn't get tiny when zoomed out, 
                        // but maybe clamp it. 
                        // actually 100px radius is fine for interactions.
                        if (!isHovering) {
                            isHovering = true;
                            const randIndex = Math.floor(Math.random() * IMAGES.length);
                            img.src = IMAGES[randIndex];
                            img.classList.add('visible');
                        }
                    } else {
                        if (isHovering) {
                            isHovering = false;
                            img.classList.remove('visible');
                        }
                    }
                }
            });

            window.addEventListener('mouseup', (e) => {
                isDragging = false;
                isPanning = false;
                // Check for Click (if dragged less than 5px)
                const distMoved = Math.hypot(e.clientX - dragStartX, e.clientY - dragStartY);
                /*
                if (distMoved < 5) {
                    // Was a click. Check center?
                    // Already handled by Hover logic essentially.
                    // But if we want explicit click action:
                    // const rect = canvas.getBoundingClientRect();
                    // const cx = CONFIG.WIDTH / 2; ...
                    // if (distCenter < 100) ...
                }
                */
            });

            // ZOOM (Mouse Wheel)
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camZ += e.deltaY * 2; // Sensitivity
                camZ = Math.max(200, Math.min(6000, camZ)); // Clamp
            }, { passive: false });

            // Touch Support (Basic)
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }
            });
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - lastMouseX;
                    const deltaY = e.touches[0].clientY - lastMouseY;
                    camAngleY += deltaX * 0.005;
                    camAngleX += deltaY * 0.005;
                    camAngleX = Math.max(-0.5, Math.min(0.5, camAngleX));
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    e.preventDefault(); // Stop scroll
                }
            });
            canvas.addEventListener('touchend', () => { isDragging = false; });

            initSnowImage();
            initParticles();
            initShapeParticles(); // NEW SHAPE
            initSnow();
            initGalaxyFloor();
            requestAnimationFrame(loop);
        }

        function initSnowImage() {
            const size = 64;
            const c = document.createElement('canvas');
            c.width = size;
            c.height = size;
            const cCtx = c.getContext('2d');

            cCtx.textAlign = 'center';
            cCtx.textBaseline = 'middle';
            cCtx.fillStyle = 'white';
            cCtx.font = '50px sans-serif';
            cCtx.fillText('‚ùÑ', size / 2, size / 2 + 4); // Adjusted for vertical centering

            snowImage = c;
        }

        function initShapeParticles() {
            shapeParticles = [];
            const R = 300;
            const r = 60;
            const centerY = 500;

            // Dense Grid: 'Th·∫≥ng h√†ng' & 'D√†y ƒë·∫∑c'
            const stepU = Math.PI * 2 / 120; // ~120 steps around
            const stepV = 4 * Math.PI / 120; // ~120 steps vertical

            for (let u = 0; u < Math.PI * 2; u += stepU) {
                for (let v = -2 * Math.PI; v < 2 * Math.PI; v += stepV) {

                    const factor = (R - r - Math.sin(v));
                    const x_raw = factor * Math.cos(u) * Math.cos(v);
                    const z_raw = factor * Math.sin(u) * Math.cos(v);
                    const y_raw = 3 * r * Math.sin(v / 2);

                    const x = x_raw;
                    const y = y_raw + centerY;
                    const z = z_raw;

                    shapeParticles.push({
                        x, y, z,
                        // Less random color, more uniform or gradient? 
                        // User said "v·∫Ω c√°c ƒëi·ªÉm s√°ng th·∫≥ng h√†ng" -> cleaner look
                        color: `hsla(${(u / (Math.PI * 2)) * 360}, 80%, 70%, `, // Rainbow along U
                        phase: v, // Wave along V
                        size: 1.0 // Uniform size for cleaner lines
                    });
                }
            }
        }

        function drawShapeParticles(now) {
            for (let i = 0; i < shapeParticles.length; i++) {
                const p = shapeParticles[i];

                // Twinkle
                const alpha = 0.5 + 0.5 * Math.sin(now * 0.003 + p.phase);

                // Rotate
                const r = applyCamera(p.x, p.y, p.z);
                // Project
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    ctx.fillStyle = p.color + alpha + ')';
                    ctx.fillRect(proj.x, proj.y, p.size * proj.scale, p.size * proj.scale);
                }
            }
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;

            // Set actual size (high res)
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;

            // Set visible size (css)
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';

            // Scale context to match logical coords
            ctx.scale(dpr, dpr);

            CONFIG.WIDTH = window.innerWidth;
            CONFIG.HEIGHT = window.innerHeight;
        }

        // --- MATH: 2D HEART ---
        function getHeartPosition(t, scale = 10) {
            const rad = t;
            // C√¥ng th·ª©c tr√°i tim 2D chu·∫©n
            const x = 16 * Math.pow(Math.sin(rad), 3);
            const y = -(13 * Math.cos(rad) - 5 * Math.cos(2 * rad) - 2 * Math.cos(3 * rad) - Math.cos(4 * rad));

            return {
                x: x * scale,
                y: y * scale
            };
        }

        function initSnow() {
            snowflakes = [];
            for (let i = 0; i < CONFIG.SNOW_COUNT; i++) {
                // Random position in big volume
                const range = 4000; // Wider snow for zoomed out view
                snowflakes.push({
                    x: (Math.random() - 0.5) * range,
                    y: (Math.random() - 0.5) * range, // Start anywhere vertically
                    z: (Math.random() - 0.5) * range,
                    // FASTER Falling Speed
                    vy: 4 + Math.random() * 4,
                    size: Math.random() * 2 + 1,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function initSnowFloor() {
            snowFloor = [];
            const floorY = 1200; // Lower floor
            const radius = 4000; // Bigger floor

            for (let i = 0; i < CONFIG.SNOW_FLOOR_COUNT; i++) {
                // Random point in circle
                const r = radius * Math.sqrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;

                snowFloor.push({
                    x: r * Math.cos(theta),
                    y: floorY, // Flat floor
                    z: r * Math.sin(theta),
                    size: Math.random() * 2 + 1,
                    alpha: Math.random() * 0.5 + 0.1
                });
            }
        }

        function drawSnowFloor() {
            for (let i = 0; i < snowFloor.length; i++) {
                const p = snowFloor[i];

                // Rotate
                const r = applyCamera(p.x, p.y, p.z);
                // Project
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    ctx.globalAlpha = p.alpha;

                    // Render Image Sprite
                    const drawSize = p.size * proj.scale * 6;
                    ctx.drawImage(snowImage, proj.x - drawSize / 2, proj.y - drawSize / 2, drawSize, drawSize);

                    ctx.globalAlpha = 1.0;
                }
            }
        }

        function initParticles() {
            particles = [];

            // Chia ƒë·ªÅu h·∫°t cho 6 tr√°i tim
            const particlesPerHeart = Math.floor(CONFIG.PARTICLES / CONFIG.HEART_COUNT);

            for (let h = 0; h < CONFIG.HEART_COUNT; h++) {
                // G√≥c xoay c·ªßa tr√°i tim n√†y (tr·ª•c ƒë·ª©ng)
                // 6 tim => m·ªói tim c√°ch nhau 60 ƒë·ªô
                const angleOffset = (Math.PI * 2 / CONFIG.HEART_COUNT) * h;

                for (let i = 0; i < particlesPerHeart; i++) {
                    // V·ªã tr√≠ ng·∫´u nhi√™n tr√™n chu vi tr√°i tim
                    const t = Math.random() * Math.PI * 2;
                    const pos2D = getHeartPosition(t, CONFIG.HEART_SIZE);

                    // B√¢y gi·ªù bi·∫øn ƒë·ªïi t·ª´ 2D th√†nh 3D b·∫±ng c√°ch xoay quanh tr·ª•c Y
                    const x3d = pos2D.x * Math.cos(angleOffset);
                    const y3d = pos2D.y;
                    const z3d = pos2D.x * Math.sin(angleOffset);

                    // Random start position (scattered)
                    const range = 4000; // Wider scatter
                    const startX = (Math.random() - 0.5) * range;
                    const startY = (Math.random() - 0.5) * range;
                    const startZ = (Math.random() - 0.5) * range;

                    particles.push({
                        startX: startX, startY: startY, startZ: startZ, // Saved Start
                        x: startX, y: startY, z: startZ, // Current
                        targetX: x3d, targetY: y3d, targetZ: z3d, // Destination
                        color: PALETTE[h % PALETTE.length],
                        phase: Math.random() * Math.PI * 2,
                        size: Math.random() * 1.2 + 0.3 // Smaller particles
                    });
                }
            }
        }

        // --- 3D PROJECTION ---
        function rotateY(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos - z * sin,
                y: y,
                z: x * sin + z * cos
            };
        }

        function rotateX(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x,
                y: y * cos - z * sin,
                z: y * sin + z * cos
            };
        }

        // Helper to apply full camera rotation
        function applyCamera(x, y, z) {
            // 1. Rotate Y (Yaw)
            let r = rotateY(x, y, z, camAngleY);
            // 2. Rotate X (Pitch)
            r = rotateX(r.x, r.y, r.z, camAngleX);
            return r;
        }

        function project(x, y, z) {
            // Use projection directly from transformed coords
            const zOffset = camZ; // Use Global Zoom
            const contextZ = z + zOffset;
            if (contextZ <= 0) return null;
            const scale = CONFIG.FOCAL_LENGTH / contextZ;
            return {
                x: x * scale + CONFIG.WIDTH / 2 + camPanX, // Add Pan X
                y: y * scale + CONFIG.HEIGHT / 2 + camPanY, // Add Pan Y
                scale: scale,
                z: z
            };
        }

        // --- LOOP ---
        function loop(now) {
            requestAnimationFrame(loop);
            if (startTime === 0) startTime = now;
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // Auto-Rotate ONLY if not dragging
            if (!isDragging) {
                camAngleY += 0.002; // Slower auto rotate
            }

            // Calculate Animation Progress
            const convergeDuration = 7000;
            let progress = (now - startTime) / convergeDuration;
            if (progress > 1) progress = 1;
            const ease = Math.pow(progress, 2.5);

            // Render Steps
            drawBackground();
            updateAndDrawSnow(now);
            drawShapeParticles(now); // Draw New Shape
            drawAccumulatedSnow(now); // Draw Accumulated Snow
            updateAndDrawGalaxyFloor(now); // Galaxy Floor
            updateAndDrawParticles(now, ease);
            drawCenterGlow();
        }

        function drawBackground() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(5, 5, 16, 0.2)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
            ctx.globalCompositeOperation = 'lighter';
        }

        // Removed initSnowFloor and drawSnowFloor function definitions here

        function updateAndDrawSnow(now) {
            const floorLevel = 500; // Match Mirror Platform height

            for (let i = 0; i < snowflakes.length; i++) {
                const s = snowflakes[i];

                // Falling
                s.y += s.vy;
                s.x += Math.sin(now * 0.001 + s.phase) * 0.5;

                // Check Collisions / Reset
                if (s.y > floorLevel) {

                    // Accumulate?
                    if (accumulatedSnow.length < MAX_ACCUMULATED) {
                        // Only if within reasonable radius (on the platform)
                        if (Math.abs(s.x) < 400 && Math.abs(s.z) < 400) {
                            accumulatedSnow.push({
                                x: s.x,
                                y: floorLevel + Math.random() * 10,
                                z: s.z,
                                color: 'rgba(255, 255, 255, ',
                                alpha: 0.5 + Math.random() * 0.3,
                                size: s.size * 1.2
                            });
                        }
                    }

                    // Reset to top
                    s.y = -1000;
                    s.x = (Math.random() - 0.5) * 2000;
                    s.z = (Math.random() - 0.5) * 2000;
                }

                // 3D Projection
                const r = applyCamera(s.x, s.y, s.z);
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    const alpha = 0.4 + 0.4 * Math.sin(now * 0.002 + s.phase);
                    ctx.globalAlpha = alpha;

                    // Render Image Sprite (Optimized)
                    const drawSize = s.size * proj.scale * 6;
                    ctx.drawImage(snowImage, proj.x - drawSize / 2, proj.y - drawSize / 2, drawSize, drawSize);

                    ctx.globalAlpha = 1.0;
                }
            }
        }

        function drawAccumulatedSnow(now) {
            for (let i = 0; i < accumulatedSnow.length; i++) {
                const p = accumulatedSnow[i];

                // Apply Camera
                const r = applyCamera(p.x, p.y, p.z);
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    ctx.fillStyle = p.color + p.alpha + ')';
                    // Draw as simple rect for performance
                    const s = p.size * proj.scale;
                    ctx.fillRect(proj.x - s / 2, proj.y - s / 2, s, s);
                }
            }
        }

        function drawSnowFloor() {
            for (let i = 0; i < snowFloor.length; i++) {
                const p = snowFloor[i];

                // Rotate
                const r = applyCamera(p.x, p.y, p.z);
                // Project
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    ctx.globalAlpha = p.alpha;

                    // Render Image Sprite
                    const drawSize = p.size * proj.scale * 6;
                    ctx.drawImage(snowImage, proj.x - drawSize / 2, proj.y - drawSize / 2, drawSize, drawSize);

                    ctx.globalAlpha = 1.0;
                }
            }
        }

        function updateAndDrawParticles(now, ease) {
            // Galaxy Flow Effect: Spiral Rotation
            // As they get closer (ease -> 1), rotation slows to 0.
            const spiral = (1 - ease) * 5.0; // 5 radians of spin during travel

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];

                // Hi·ªáu ·ª©ng th·ªü / rung rinh C·ª¶A TARGET
                const breathingScale = 1 + 0.05 * Math.sin(now * 0.003 + p.phase);

                const finalXx = p.targetX * breathingScale;
                const finalYy = p.targetY * breathingScale;
                const finalZz = p.targetZ * breathingScale;

                // Basic Interpolation
                const lerpX = p.startX + (finalXx - p.startX) * ease;
                const lerpY = p.startY + (finalYy - p.startY) * ease;
                const lerpZ = p.startZ + (finalZz - p.startZ) * ease;

                // --- VORTEX TWIST ---
                // Rotate the current interpolated position around Y axis
                // This creates the spiral "galaxy" path
                const cosS = Math.cos(spiral);
                const sinS = Math.sin(spiral);

                // Spiral around center (0,0)
                p.x = lerpX * cosS - lerpZ * sinS;
                p.z = lerpX * sinS + lerpZ * cosS;
                p.y = lerpY;

                // Add a bit of "Galaxy Noise" that fades out
                if (ease < 1) {
                    const noise = (1 - ease) * 50 * Math.sin(now * 0.01 + p.phase);
                    p.x += noise;
                    p.y += noise;
                    p.z += noise;
                }

                // 1. Apply Camera (Y then X)
                const r = applyCamera(p.x, p.y, p.z);
                const proj = project(r.x, r.y, r.z);

                if (proj) {
                    const alphaBase = 0.5 + 0.5 * Math.sin(now * 0.005 + p.phase);
                    const size = p.size * proj.scale;

                    ctx.fillStyle = p.color + alphaBase + ')';

                    // Optimized: fillRect instead of arc
                    ctx.fillRect(proj.x - size / 2, proj.y - size / 2, size, size);
                }
            }
        }

        function drawCenterGlow() {
            const centerProj = project(0, 0, 0);
            const container = document.getElementById('image-container');

            if (centerProj) {
                // Glow t√¢m
                const grad = ctx.createRadialGradient(centerProj.x, centerProj.y, 0, centerProj.x, centerProj.y, 30 * centerProj.scale);
                grad.addColorStop(0, 'white');
                grad.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(centerProj.x, centerProj.y, 30 * centerProj.scale, 0, Math.PI * 2);
                ctx.fill();

                // UPDATE IMAGE POSITION
                // Move the container to the projected center
                container.style.left = centerProj.x + 'px';
                container.style.top = centerProj.y + 'px';
                container.style.display = 'flex';
            } else {
                if (container) container.style.display = 'none';
            }
        }

        init();
    </script>
</body>
</html>