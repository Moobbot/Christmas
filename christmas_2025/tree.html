<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cây Thông 3D - Sáng Ấm (Balanced)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }

    canvas {
      display: block;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      pointer-events: none;
      font-size: 1.2rem;
      transition: opacity 0.5s;
    }

    .instruction {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-family: sans-serif;
      pointer-events: none;
      select: none;
      text-shadow: 0 0 5px #000;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <div id="loading">Đang tăng độ sáng...</div>
  <div class="instruction">Giữ chuột trái để XOAY | Lăn chuột để ZOOM</div>

  <script>
    window.onload = function () {
      if (typeof THREE === 'undefined') {
        document.getElementById('loading').innerHTML = "Lỗi kết nối mạng!";
        return;
      }
      init();
    };

    function init() {
      const loadingEl = document.getElementById('loading');
      loadingEl.style.opacity = 0;
      setTimeout(() => loadingEl.style.display = 'none', 500);

      // 1. SETUP - NỀN XÁM ĐEN (Không để đen tuyền nữa cho đỡ tối)
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      scene.fog = new THREE.FogExp2(0x111111, 0.015);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 30, 65);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Tone Mapping giúp màu sắc rực rỡ mà không bị cháy sáng
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;

      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      // 2. HỆ THỐNG ÁNH SÁNG CÂN BẰNG

      // A. Ánh sáng môi trường (Ambient): Giúp nhìn thấy mọi thứ trong bóng tối
      // Màu vàng kem nhẹ, cường độ 0.4 (đủ sáng để thấy chi tiết)
      const ambientLight = new THREE.AmbientLight(0xffeeb1, 0.4);
      scene.add(ambientLight);

      // B. Đèn bán cầu (Hemisphere): Giả lập ánh sáng tự nhiên (Trời xanh nhẹ + Đất tối)
      // Giúp cây có khối lượng đẹp hơn
      const hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.3);
      scene.add(hemiLight);

      // C. ĐÈN CHÍNH (SpotLight) - ẤM ÁP
      const spotLight = new THREE.SpotLight(0xffaa33, 5); // Cường độ tăng lên 5
      spotLight.position.set(40, 80, 40);
      spotLight.angle = Math.PI / 3.5; // Góc chiếu rộng hơn (để không bị tối xung quanh)
      spotLight.penumbra = 0.3; // Mềm mại
      spotLight.decay = 2;
      spotLight.distance = 200;

      spotLight.castShadow = true;
      spotLight.shadow.mapSize.width = 2048;
      spotLight.shadow.mapSize.height = 2048;
      spotLight.shadow.bias = -0.0001;

      scene.add(spotLight);

      // 3. CÂY THÔNG
      const treeGroup = new THREE.Group();
      const leafMaterial = new THREE.MeshStandardMaterial({
        color: 0x0f5f0f,
        roughness: 0.6, // Giảm roughness để lá cây bắt sáng tốt hơn 
        flatShading: true
      });

      const layers = 5;
      for (let i = 0; i < layers; i++) {
        const radius = 12 - i * 2.2;
        const height = 9;
        const cone = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 12), leafMaterial);
        cone.position.y = i * 5 + 6;
        cone.castShadow = true;
        cone.receiveShadow = true;
        treeGroup.add(cone);

        addVariedBaubles(cone.position.y, radius, i, treeGroup);
      }

      // Thân cây
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(2.5, 3, 12, 8),
        new THREE.MeshStandardMaterial({ color: 0x3d2817 })
      );
      trunk.position.y = 1;
      trunk.castShadow = true;
      treeGroup.add(trunk);

      // 4. NGÔI SAO
      const starShape = new THREE.Shape();
      const points = 5; const outerRadius = 3; const innerRadius = 1.5;
      starShape.moveTo(0, outerRadius);
      for (let i = 1; i < points * 2; i++) {
        const angle = (i / (points * 2)) * Math.PI * 2;
        const r = (i % 2 === 0) ? outerRadius : innerRadius;
        starShape.lineTo(Math.sin(angle) * r, Math.cos(angle) * r);
      }
      starShape.closePath();

      const extrudeSettings = { steps: 1, depth: 0.8, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 2 };
      const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
      starGeo.center();

      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffcc00,
        emissive: 0xff8800,
        emissiveIntensity: 0.6,
        metalness: 0.8, roughness: 0.1
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.y = layers * 5 + 7.5;
      treeGroup.add(star);

      // Đèn phụ tại ngôi sao để làm sáng đỉnh cây
      const starLight = new THREE.PointLight(0xffaa00, 1, 50);
      starLight.position.set(0, layers * 5 + 7, 0);
      treeGroup.add(starLight);

      scene.add(treeGroup);

      // 5. MÔI TRƯỜNG (Sàn sáng hơn chút)
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300),
        new THREE.MeshStandardMaterial({
          color: 0xeeeeee, // Sàn màu trắng xám bắt sáng tốt
          roughness: 0.8
        })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -4;
      ground.receiveShadow = true;
      scene.add(ground);

      const snowGeo = new THREE.BufferGeometry();
      const snowCount = 2000;
      const pos = [];
      for (let i = 0; i < snowCount; i++) pos.push((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 100 + 50, (Math.random() - 0.5) * 150);
      snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
      const snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8 }));
      scene.add(snowSystem);

      // 5b. TUYẾT TÍCH TỤ (ACCUMULATION)
      const maxAccumulated = 50000; // Tăng dung lượng bộ nhớ đệm
      const accPos = new Float32Array(maxAccumulated * 3);
      const accGeo = new THREE.BufferGeometry();
      accGeo.setAttribute('position', new THREE.BufferAttribute(accPos, 3));
      accGeo.setDrawRange(0, 0); // Ban đầu chưa có gì

      const accMat = new THREE.PointsMaterial({
        color: 0xffaa00,
        size: 0.25, // To hơn chút để dễ thấy
        transparent: true,
        opacity: 0.6
      });
      const accumulatedSnowSystem = new THREE.Points(accGeo, accMat);
      scene.add(accumulatedSnowSystem);

      let accumulatedCount = 0;

      // 6. ANIMATION
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        star.rotation.y -= 0.015;

        const p = snowSystem.geometry.attributes.position.array;
        for (let i = 1; i < p.length; i += 3) {
          p[i] -= 0.12;

          if (p[i] < -4) {
            // 1. Tích tụ
            if (accumulatedCount < maxAccumulated) {
              const x = p[i - 1];
              const z = p[i + 1];
              // Chỉ tích tụ nếu rơi trong vùng sàn (bán kính 150)
              if (Math.abs(x) < 140 && Math.abs(z) < 140) {
                accPos[accumulatedCount * 3] = x;
                accPos[accumulatedCount * 3 + 1] = -4 + Math.random() * 0.8;
                accPos[accumulatedCount * 3 + 2] = z;
                accumulatedCount++;
                accGeo.setDrawRange(0, accumulatedCount);
                accGeo.attributes.position.needsUpdate = true;
              }
            }
            // 2. Reset
            p[i] = 80;
            p[i - 1] = (Math.random() - 0.5) * 150;
            p[i + 1] = (Math.random() - 0.5) * 150;
          }
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
      }
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      animate();
    }

    // --- HÀM TẠO BÓNG ---
    function addVariedBaubles(y, radius, layerIndex, group) {
      const count = Math.floor(radius * 3.5);
      const colors = [0xff0000, 0xffff00, 0x00ffff, 0xff00ff, 0xffaa00, 0xffffff, 0x00ff00];
      const geometries = [
        new THREE.SphereGeometry(0.5, 32, 32),
        new THREE.IcosahedronGeometry(0.5, 0),
        new THREE.OctahedronGeometry(0.5, 0),
        new THREE.TorusKnotGeometry(0.3, 0.1, 64, 8)
      ];

      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2 + layerIndex;
        const randomGeoIndex = Math.floor(Math.random() * geometries.length);
        const selectedGeo = geometries[randomGeoIndex];
        const color = colors[i % colors.length];

        const mat = new THREE.MeshStandardMaterial({
          color: color, roughness: 0.1, metalness: 0.8,
          emissive: color,
          emissiveIntensity: 0.5 // Tăng độ phát sáng lên mức trung bình
        });

        const mesh = new THREE.Mesh(selectedGeo, mat);
        const randomScale = Math.random() * 1.3 + 0.7;
        mesh.scale.set(randomScale, randomScale, randomScale);

        mesh.position.set(
          Math.cos(angle) * (radius - 0.5),
          y - 3,
          Math.sin(angle) * (radius - 0.5)
        );

        if (randomGeoIndex === 3) {
          mesh.rotation.set(Math.random(), Math.random(), Math.random());
        }

        group.add(mesh);
      }
    }
  </script>
</body>
</html>